# 1장. 마이크로서비스


## 1.1 마이크로서비스란

### 1.1.1 작고, 한 가지 일을 잘하는 데 주력
> "같은 이유로 변경되는 것들은 한데 모으고, 서로 다른 이유로 변경되는 것들은 분리하라." - Robert C. Martin 단일책임원칙
> "얼마나 작아야 작은 것인가?" '마이크로서비스란 2주 안에 재작성될 수 있는 것'이라고 특정한다. - Jon Eaves [RealEstate](http://realestate.com.au)

### 1.1.2 자율성
> 서비스들은 서로 독립적으로 변경될 수 있어야 하고, 소비자consumer를 변경할 필요 없이 독립적으로 배포될 수 있어야 한다.
> 이 때에 우리는 서비스가 무엇을 외부에 드러내고 무엇을 내부에 두어야 하는지 고민해야 한다.


## 1.2 주요 혜택

### 1.2.1 기술 이기종성
> 폴리글랏 프로그래밍, 마이크로 서비스 아키텍처, JVM 기반 언어 지향 등과 같이 서비스 간의 지나친 결합 없이 독립적으로 기술을 진화시키는 기술

### 1.2.2 회복성
> 회복 공학resilience engineering의 핵심 개념은 '격벽bulkhead'이다. - 현재 시스템의 장애가 다른 시스템에 영향을 미치지 않도록 구성하는 것.
> 네트워크도 머신처럼 장애가 발생할 수 있는 만큼 이것을 다루는 방법을 이해해야 하며 소프트웨어 최종 사용자에게 어떤 영향을 미치는지도 알아야 한다.

### 1.2.3 확장성
> 어느 한 부분의 성능향상을 위해 모든 어플리케이션에 영향을 미치는 모노리식 아키텍처는 확장성이 떨어진다
> AWS에서 제공하는 것과 같이 주문형 프로비저닝 시스템을 도입하는것도 효과적인 방법이다.

### 1.2.4 배포 용이성
> 자그마한 변경에 전체 어플리케이션의 배포는 배포 자체를 주저하게 만들고, 이는 한 번에 많은 비용을 들여서 배포하게 하는 악순환을 만든다.
> 손쉽게 개별 시스템을 배포 및 롤백할 수 있는 환경의 아키텍처를 설계하는 것이 중요하다

### 1.2.5 조직 부합성
> 작은 팀이 작은 코드베이스로 일할 때 생산적이며, 마이크로서비스를 통해 아키텍처를 조직에 맞게 더 적절히 정렬할 수도 있다.

### 1.2.6 조합성
> 많은 기능을 재사용할 수 있도록 다양한 애플리케이션(웹, 네이티브 앱, 모바일 웹, 태블릿 앱 등)을 통합할 수 있는 아키텍처.

### 1.2.7 대체 가능성을 위한 최적화
> 그 누구도 손대기 싫어하는 한 귀퉁이에 자리하고 있는 크고 지저분한 레거시 시스템.
> 서비스의 재작성 및 삭제가 용이하도록 설계할 수 있는 환경 및 아키텍처.



## 1.3 서비스 지향 아키텍처란


## 2.3 구역화
> 아키텍트로서 우리는 구역 **내**의 일보다는 구역 **사이**에서 발생하는 일을 더 걱정해야 한다. 이것은 아키텍트가 서비스 간 통신 방법에 대해 고민하거나 시스템의 전반적인 상태를 적절히 모니터링하는 데 더 많은 시간을 할애해야 한다는 것을 의미한다. 

## 코딩하는 아키텍트
> 아키텍트가 팀과 함께 시간을 보내고, 이상적으로는 팀과 함께 실제로 코딩하는 것을 의미한다. 짝 프로그래밍pair programming 활용도 좋다.


## 2.4 원칙적인 접근법

### 2.4.1 전략적인 목표
> 회사가 나아가는 방향, 목표와 핵심전략이 일치해야만 한다. 아마도 비기술적인 영역이 대부분일 것이다.

### 2.4.2 원칙
> 원칙의 수는 10개 미만으로 쉽게 기억하고 벽보에 붙일 수 있는 개수로 정한다.

### 2.4.3 실천사항
> 어떤 개발자든 이해할 수 있도록 구체적이어야만 하며, 아키텍트의 원칙을 뒷받침해야 한다.


## 2.5 필수 기준
> 우리가 큰 틀에서 시스템을 생각한다면 '자율적인 수명주기를 가지면서도 함께 협업하는 수많은 작은 부품으로 구성된 응집력 있는 시스템이 되어야 한다.' 그러므로 우리는 거시적 시각을 잃지 않으면서도 개별 마이크로서비스 간의 자율성 최적화와 관련한 균형을 찾아야 한다. 이를 위한 확실한 방법 중 하나는 각 서비스가 가져야 할 명확한 속성을 정의하는 것이다.

### 2.5.1 모니터링
> 통일된 지표metrics 전송방식을 고수하고 한 곳에서 수집되도록 할 것

### 2.5.2 인터페이스
> 서비스 간 인터페이스 개수는 최소화 할 것

### 2.5.3 아키텍처 안정성
> 하나의 오동작 서비스가 시스템 전체를 망치게 해서는 안된다.


## 2.6 코드를 통한 통제
> 한 자리에서 같이 코딩하자 대신에 좋은 코드 템플릿을 제공하는 것이 낫다.



## 2.7 기술 부채technical debt
> 긴급 기능 배포를 위해 절차를 무시하거나, 기술 비전을 충실히 이해하지 못할 수 있다.
> 아키텍트의 역할은 더 큰 그림을 보고 균형을 이해하는 것이며, 부채 수준과 연관성을 고찰하는 것은 중요하다.
> 팀 스스로가 부채를 찾아내서 상환하는 방법을 결정할 수 있으며, 정기적인 부채로그 검토를 통해 관리 및 체계화가 중요하다.




